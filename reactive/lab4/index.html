<HTML>
<HEAD>
<META http-equiv="content-type" content="text/html; charset=utf-8">
<TITLE>Scala</TITLE>
<link rel="stylesheet" type="text/css" href="../style.css">
</HEAD>
<BODY>
<TABLE WIDTH="80%" HEIGHT="90%" BORDER="0" ALIGN=CENTER>
<TR>
<TD ALIGN=CENTER>
<DIV ALIGN=left>

<hr>
    <H2>Programowanie reaktywne w języku Scala</H2>
<hr>

<h2>Zarządzanie stanem aktorów</h2>

    <H3>Separacja logiki dziedzinowej</H3>
Dobrą praktyką w projektowaniu systemu aktorów jest oddzielenie logiki dziedzinowej od logiki komunikacji. 
    Przykładowo aktor Cart nie powinien implementować jednocześnie stanu koszyka i protokołu komunikacji, bo 
    utrudnia to testowanie samej logiki biznesowej (stanu koszyka) -- można to robić tylko przez asynchroniczny
    protokół komunikacji. W tym przypadku najlepiej wydzielić klasę <TT>Cart</TT> reprezentująca obiekt dziedzinowy
    i aktora <TT>CartManager</TT> implementującego protokół komunikacji:
    
    <pre>
    case class Item(id: URI, name: String, price: BigDecimal, count: Int) // item is identified by a unique URI (java.net.URI)
    case class Cart(items: Map[URI, Item]) {       
    def addItem(it: Item, cnt: Int): ShoppingCart = {
        val currentCount = items.get(it.id).getOrElse(0)
        copy(items = items.updated(it.id, it.copy(count = currentCount + cnt))
      }
      def removeItem(id: Item, cnt: Int) = ???
    }
    object Cart {
      val empty = Cart(Map.empty)
    }
    
    class CartManager(var shoppingCart: ShoppingCart) extends Actor {
      def this() = this(ShoppingCart.empty)
      
      def receive = {
        case AddItem(item, count) => ???
        case RemoveItem(item, count) => ???
        ...
      }
    }
    </pre>
    
    <H3>Utrwalanie i odtwarzanie stanu</H3>
<ul>
<li>W celu utrwalania stanu aktora, używamy wzorca <TT>Event Sourcing</TT> zaimplementowanego w bibliotece <a href="http://doc.akka.io/docs/akka/current/scala/persistence.html">
Akka persistence</a>.
<li> Przykładowy projekt używający persystencji Akki
<pre>
git clone https://github.com/malawski/reactive-lab4.git
cd reactive-lab4
sbt eclipse
</pre>
</li>
<li>Proszę sprawdzić zachowanie aktora <tt>PersistentBankAccount</tt> przy kilkukrotnym uruchomieniu projektu. Co się zmienia, gdy wyślemy do niego komunikat <TT>Snap</TT>?
<li>Projekt wykorzystuje wbudowaną bazę danych LevelDB do zapisu dziennika zdarzeń. Pliki bazy tworzone są w katalogu <TT>target/journal/.</TT> (dla eventów) oraz <tt> target/snapshot/. </tt> (dla snapshotów). 
<li>Baza używa wbudowanej implementacji w Javie, co skonfigurowane jest w pliku <a href="https://github.com/malawski/reactive-lab4/blob/master/src/main/resources/application.conf"><TT>src/main/resources/application.conf</TT></a>.
<li>Przykład użycia persystencji dla aktora wykorzystującego <TT>context.become()</TT> zamieszczony jest w pliku: <a href="https://github.com/malawski/reactive-lab4/blob/master/src/main/scala/reactive4/persistence/PersistentToggle.scala">PersistentToggle.scala</a>. 
<li>Przykład użycia persystencji dla aktora wykorzystującego <TT>FSM</TT> zamieszczony jest w pliku: <a href="https://github.com/malawski/reactive-lab4/blob/master/src/main/scala/reactive4/fsm/PersistentToggleFSM.scala">PersistentToggleFSM.scala</a>. Uwaga: pakiet <tt>akka.persistence.fsm</tt> jest na razie eksperymentalny.

</ul>

<H3>Zadanie</H3>
<OL>
    <LI>(20 pkt) Separacja logiki dziedzinowej i persystencja koszyka
    <UL>
        <LI>Proszę wydzielić osobną klasę <TT>Cart</TT> do implementacji stanu koszyka i aktora <TT>CartManager</TT>, który
            obsługuje komunikację i przechowuje stan koszyka jako instancję <TT>Cart</TT>. 
            
        <li>Proszę zaimplementować persystencję stanu koszyka przy pomocy mechanizmu event sourcingu. Proszę zwrócić uwagę na poprawne 
            odtwarzanie timerów. 
    </UL>
    <P>
    <LI>(10 pkt) Przetestować scenariusz, w którym przed upływem końca aukcji aplikacja zostaje wyłączona 
        (np. poprzez <TT>system.shutdown()</TT>). Po ponownym uruchomieniu aplikacji stan aktora <B>CartManager</B> powinien 
        być odtworzony z dziennika. 
    <P>
    <LI>(10 pkt) Proszę porównać wydajność różnych mechanizmów persystencji (np. LevelDB z opcją native = true/false, 
        InMemory, itp., <a href="http://akka.io/community/">lista wtyczek</a>) i oszacować średni czas zapisu/odczytu zdarzenia.
    <UL>

    </UL>
</OL>
<!--
<H3>Bibliografia</H3>
<OL>
</OL>
!-->
<P>
<P>
<HR>
<I>Bartosz Baliś, balis at agh edu pl</I>
<BR>
<I>Maciej Malawski, malawski at agh edu pl</I>
<BR>
<I>Katarzyna Rycerz, kzajac at agh edu pl</I>
<BR>
<P> <P>
</DIV>
</TR>
</TD>
</TABLE>
</BODY>
</HTML>
